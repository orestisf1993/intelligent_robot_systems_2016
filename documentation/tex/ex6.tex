\section{Challenge 6: Εξυπνότερη επιλογή τελικού στόχου}
Η επιλογή επόμενου στόχου ρομπότ γίνεται στο αρχείο
\path{./art_autonomous_exploration/src/target_selection.py}
και μέχρι τώρα γινόταν με τη τυχαία επιλογή ενός σημείου του OGM το οποίο δεν είναι ήδη καλυμμένο και δεν περιέχει εμπόδια.
Αυτή η στρατηγική έχει ως αποτέλεσμα το όχημα να μεταφέρεται σε διάφορα σημεία του χάρτη χωρίς να συμπεριλαμβάνεται η τοπολογική πληροφορία και η τοποθεσία του ρομπότ.

Για μια πιο ``έξυπνη'' συμπεριφορά του ρομπότ επιλέχθηκε στρατηγική επιλογή κόμβου τοπολογικού γράφου με βάση συνδυασμού βαρών
όπως στη \cite{etsardou-phd} και \cite{tsardoulias2016cost}.
Αυτό σημαίνει ότι για τους κόμβους του τοπολογικού γράφου παράγουμε τις διαδρομές μέσω της
\mintinline{python}!PathPlanning.createPath()! του
\path{./art_autonomous_exploration/src/path_planning.py} και τις αξιολογούμε με το σταθμισμένο άθροισμα 4 μετρικών που θα αναλυθούν στη συνέχεια.

Ο τοπολογικός γράφος προκύπτει από το generalized Voronoi diagram (γενικευμένο διάγραμμα Voronoi - GVD).
Η χρήση του GVD είναι βολική καθώς αν το ρομπότ το διασχίσει θα βρίσκεται στο κέντρο του ελεύθερου χώρου, μακριά από τα εμπόδια.
Τα ακριανά σημεία καλύπτονται με τη βοήθεια του \hyperref[section:topo-cost]{τοπολογικού κόστους}.

\subsection{Προετοιμασία και φιλτράρισμα πιθανών κόμβων}
Ένα από τα σημαντικότερα προβλήματα που αντιμετωπίστηκαν ήταν οι σημαντικές καθυστερήσεις που παρουσιαζόντουσαν στον υπολογισμό των διαδρομών όταν ένα σημαντικό μέρος του χάρτη είχε υπολογιστεί.
Προς το τέλος της εκτέλεσης ο υπολογισμός του path χρειαζόταν μέχρι και 6-7 δευτερόλεπτα με τιμή
\texttt{0.3} στο \texttt{uniform\_sampling\_step}~(βλ.~\ref{section:uniform-sampling}).
Για να αποφευχθούν οι τεράστιες καθυστερήσεις εφαρμόστηκε ένα αρχικό ``φιλτράρισμα'' των πιθανών κόμβων.
Η διαδικασία αυτή γίνεται από τη συνάρτηση \mintinline{python}!chooseBestNodes()!:
\begin{itemize}
    \item Γίνεται clustering των πιθανών τοπολογικών κόμβων μέσω του αλγορίθμου k-means στη συνάρτηση \mintinline{python}!clusterNodes()!.
          Επιλέχθηκε η ομαδοποίηση των κόμβων σε
          10 (ρυθμίζεται μέσω \path{./art_autonomous_exploration/config/autonomous_expl.yaml}) clusters.
          Χρησιμοποιείται η \mintinline{python}!kmeans2! της βιβλιοθήκης \mintinline{python}!scipy.cluster.vq!
          που προσφέρει η~\cite{scipy}.
          Τελικά επιλέγεται από κάθε cluster ο μακρινότερος από το ρομπότ σύμφωνα με την Ευκλείδια απόσταση κόμβος.
          Εναλλακτικό κριτήριο θα μπορούσε να είναι το \hyperref[section:topo-cost]{τοπολογικό κόστος} του κάθε κόμβου ή να γίνεται επιλογή του πιο κεντρικού κόμβου κάθε cluster.
          Με αυτό το τρόπο αποφεύγεται ο υπολογισμός του κόστους για πολλούς κοντινούς κόμβους.

    \item Για τους κόμβους που επιστρέφονται από τη \mintinline{python}!clusterNodes()! υπολογίζονται το
          \hyperref[section:topo-cost]{τοπολογικό κόστος} και το \hyperref[section:distance-cost]{κόστος απόστασης}.
          Ο υπολογισμός γίνεται ωστόσο μόνο για το τελικό σημείο αντί για ολόκληρο το μονοπάτι.
          Ταξινομούνται οι κόμβοι σύμφωνα με αυτά τα κόστη και επιλέγονται οι
          7 (ρυθμίζεται μέσω \path{./art_autonomous_exploration/config/autonomous_expl.yaml}) καλύτεροι για τους οποίους μπορεί να παραχθεί επιτυχώς path.

    \item Σε περίπτωση που δεν μπορεί να παραχθεί για κανέναν κόμβο μονοπάτι ενεργοποιείται μια ``fallback'' επιλογή στόχου.
          %TODO: fallback σε closer και γιατι + scrot. Εναλλακτική ιδέα να προσπαθήσουμε να χρησιμοποιήσουμε ανεξερεύνητο χώρο και να βρούμε clusters από εκεί. Θα μπορούμε να επιλέγουμε απλως το κοντινοτερο αφού συνηθως εχουν μεινει μονο γωνιες.
          Αντί για τον συνδυασμό βαρών επιλέγεται το κοντινότερο σημείο του OGM το οποίο δεν είναι ήδη καλυμμένο και δεν περιέχει εμπόδια.
          Σαν συνάρτηση απόστασης χρησιμοποιείται η απλή Ευκλείδια.
          Η υλοποίηση βρίσκεται στη συνάρτηση \mintinline{python}!closerNode()!.

          Αυτό συμβαίνει συνήθως όταν έχει καλυφθεί σχεδόν ολόκληρος ο χάρτης οπότε επιλέχθηκε να μονιμοποιείται η ενεργοποίηση της fallback επιλογής στόχου.
          Δηλαδή, τη πρώτη φορά που αποτύχει η παραγωγή οποιουδήποτε μονοπατιού θέτουμε
          \mintinline{python}!self.method = 'cost_based_fallback'!
          και οποιαδήποτε επόμενη κλήση της \mintinline{python}!chooseBestNodes()! χρησιμοποιεί απευθείας την \mintinline{python}!closerNode()!.
          Η υπόλοιπη διαδικασία που περιγράφεται σε αυτή την ενότητα αγνοείται.

          Τελικό ``fallback'' αποτελεί πάντα η \mintinline{python}!selectRandomTarget()! αν δεν μπορεί να βρεθεί πιθανό path και χρησιμοποιηθεί το argument \mintinline{python}!force_random! στη \mintinline{python}!selectTarget()!.
\end{itemize}

\subsection{Τοπολογικό κόστος}\label{section:topo-cost}
Το τοπολογικό κόστος είναι μια ένδειξη της τοποθεσίας κάθε κόμβου στο χώρο.
Με το τοπολογικό κόστος προσπαθούμε να προτιμήσουμε την επιλογή σημείων που βρίσκονται κοντά σε εμπόδια / τοίχους και γωνίες.
Περιοχές με υψηλό τοπολογικό κόστος είναι αυτές που το ρομπότ θα περάσει ώστε να μεταφερθεί στο στόχο του.
Δηλαδή, κεντρικές περιοχές με αρκετό χώρο προς όλες τις κατευθύνσεις~\cite{etsardou-phd}.
Σαν τοπολογικό κόστος θέτουμε, όπως και στη~\cite{etsardou-phd,tsardoulias2016cost} το άθροισμα των αποστάσεων του κόμβου από τα εμπόδια του χώρου σε 8 κατευθύνσεις.
\begin{equation}
    w_{topo} = \sum_{i=1}^{8} D_i
\end{equation}

Ο υπολογισμός του τοπολογικού κόστους γίνεται στη συνάρτηση \mintinline{python}!topologicalCost()!.
Σαν \mintinline{python}!threshold! χρησιμοποιείται η τιμή \mintinline{python}!200!.
Η κάθε απόσταση $D_i$ υπολογίζεται ως $(x-x_c)^2 + (y-y_c)^2$ όπου $x, y$ η θέση του κόμβου και $x_c, y_c$ η θέση μετά από \mintinline{python}!idx! μετακινήσεις προς τη κατεύθυνση \mintinline{python}!dir_x, dir_y!.
Η αύξηση του \mintinline{python}!idx! σταματάει όταν βρεθεί εμπόδιο ή αν η τιμή του $D_i$ φτάσει το \mintinline{python}!threshold!.
Στη περίπτωση που βρεθεί άγνωστο σημείο παίρνουμε $D_i$ ίσο με \mintinline{python}!threshold! όπως και στη~\cite{etsardou-phd}.
\begin{code}
\caption{Υπολογισμός τοπολογικού κόστος}
\begin{pythoncode}
@staticmethod
def topologicalCost(node, ogm, threshold):
    result = 0
    for dir_x, dir_y in [(0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1)]:
        cost = 0
        idx = 0
        x, y = node
        while cost < threshold:
            idx += 1
            x_c = x + idx * dir_x
            y_c = y + idx * dir_y
            cost = (x - x_c) ** 2 + (y - y_c) ** 2
            if ogm[x_c][y_c] > 50:
                break
            elif ogm[x_c][y_c] in [50, -1]:
                Print.art_print("{},{} is unknown!".format(x_c, y_c), Print.RED)
                cost = threshold
                break
        result += min(threshold, cost)
    return result
\end{pythoncode}
\end{code}

%TODO: σειρά;
\subsection{Κόστος απόστασης}\label{section:distance-cost}
Το κόστος απόστασης υλοποιείται στη συνάρτηση \mintinline{python}!distanceCost()!.
Η τιμή του αποτελεί το άθροισμα των γινομένων των Ευκλείδιων αποστάσεων μεταξύ τον κόμβων του μονοπατιού και ενός συντελεστή που υπολογίζεται στη \mintinline{python}!distanceCoeff()!.
Ο τύπος του συντελεστή αυτού από τη~\cite{etsardou-phd} είναι:
\begin{equation}
    {w_{dist}}_{coeff} = \frac{1}{1 - e^{-\left(
                \frac{\left({x_n}_i - x_g\right)^2}{2 \sigma^2} +
                \frac{\left({y_n}_i - y_g\right)^2}{2 \sigma^2}
                \right)} + \epsilon}
\end{equation}
για τον κόμβο $i$ με συντεταγμένες ${x_n}_i, {y_n}_i$ και συντεταγμένες ρομπότ $x_g, y_g$.
Ως $\sigma$ επιλέχθηκε η τιμή $30$ %TODO sigma?
καθώς η τιμή $100$ από τη~\cite{tsardoulias2016cost} οδηγούσε σε αρκετά μακρινούς στόχους.
Επίσης $\epsilon = 0.0001$ για να αποφεύγεται ο μηδενισμός του παρανομαστή.

\subsection{Κόστος κάλυψης μονοπατιού}\label{section:coverage-cost}
\sloppy Ως κόστος κάλυψης ορίζουμε το άθροισμα του πίνακα \mintinline{python}!coverage! για το δοσμένο μονοπάτι:
\mintinline{python}!coverage_sum = sum(coverage[x][y] for x, y in path)!.

Το κόστος αυτό εκφράζει την επιθυμία μας να μην επαναλαμβάνουμε την προσπέλαση ήδη καλυμμένων περιοχών.

\subsection{Κόστος περιστροφής μονοπατιού}\label{section:rotation-cost}
Ως κόστος περιστροφής θέτουμε το άθροισμα των απολύτων τιμών των γωνιών που πρέπει να περιστραφεί το ρομπότ ώστε να καλύψει το μονοπάτι:
\begin{equation}
    w_{rot} = \sum_{i=1}^{\text{PathSize}} \abs{\theta_i}
\end{equation}
Η διαφορά με τη~\cite{etsardou-phd} είναι ότι χρησιμοποιείται η απόλυτη τιμή των γωνιών.

\subsection{Τελική επιλογή στόχου}
Αφού υπολογιστούν τα κόστη που αναφέρθηκαν προηγουμένως, σταθμίζονται με τη συνάρτηση \mintinline{python}!weightCosts()!.
Καθώς όλα τα κόστη είναι θετικά χρησιμοποιείται η σχέση:
\begin{equation}
    1 - \frac{w}{\max{\abs{w}}}
\end{equation}
για κάθε κόστος $w$.
Η κανονικοποίηση αυτή φέρνει τα κόστη στο διάστημα $\left[0, 1\right]$.

Τελικά, υπολογίζουμε τον σταθμισμένο μέσο και επιλέγουμε το στόχο που αντιστοιχεί στο μεγαλύτερο αποτέλεσμα (λόγω της αφαίρεσης από το $1$).
Σαν βάρη χρησιμοποιούμε τις τιμές:%TODO: σειρά
\begin{itemize}
    \item $2^4$ για το τοπολογικό κόστος
    \item $2^3$ για το κόστος απόστασης
    \item $2^2$ για το κόστος κάλυψης
    \item $2^1$ για το κόστος περιστροφής
\end{itemize}
Η σειρά προτεραιότητας είναι σύμφωνη με τη~\cite{etsardou-phd}.

\subsection{Άλλες πιθανές βελτιώσεις}
Πέρα από τα σχόλια σε αυτή τη παράγραφο μερικές ακόμα ιδέες για τη βελτίωση της ποιότητας της επιλογής στόχους αποτελούν:
\begin{itemize}
    \item Γενικά η βελτίωση της ταχύτητας της διαδικασίας.
          Αυτό μπορεί να γίνει με τη βελτίωση του κώδικα κατασκευής μονοπατιών ή η αλλαγή μεθοδολογίας, η παραλληλοποίηση της κατασκευής μονοπατιών για πολλά nodes ή ακόμη και η μετατροπή του target selection ώστε να χρησιμοποιούνται μόνο nodes και όχι τα paths.

    \item Η επαναχρησιμοποίηση του υπολογισμένου path στη \path{./art_autonomous_exploration/src/navigation.py}.
          Η \mintinline{python}!selectTarget()! θα μπορούσε να επιστρέφει το path αφού ήδη υπολογίζεται.
\end{itemize}
